"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var webpack_1 = require("webpack");
var ts = require("typescript");
var path_1 = require("path");
var license_webpack_plugin_1 = require("license-webpack-plugin");
var CircularDependencyPlugin = require("circular-dependency-plugin");
var ForkTsCheckerWebpackPlugin = require("fork-ts-checker-webpack-plugin");
var CopyWebpackPlugin = require("copy-webpack-plugin");
var typescript_1 = require("../typescript");
exports.OUT_FILENAME = 'main.js';
function getBaseWebpackPartial(options) {
    var compilerOptions = typescript_1.readTsConfig(options.tsConfig).options;
    var supportsEs2015 = compilerOptions.target !== ts.ScriptTarget.ES3 &&
        compilerOptions.target !== ts.ScriptTarget.ES5;
    var webpackConfig = {
        entry: {
            main: [options.main]
        },
        devtool: options.sourceMap ? 'source-map' : false,
        mode: options.optimization ? 'production' : 'development',
        output: {
            path: options.outputPath,
            filename: exports.OUT_FILENAME
        },
        module: {
            rules: [
                {
                    test: /\.(j|t)sx?$/,
                    loader: "ts-loader",
                    options: {
                        configFile: options.tsConfig,
                        transpileOnly: true,
                        // https://github.com/TypeStrong/ts-loader/pull/685
                        experimentalWatchApi: true
                    }
                }
            ]
        },
        resolve: {
            extensions: ['.ts', '.tsx', '.mjs', '.js', '.jsx'],
            alias: getAliases(options, compilerOptions),
            mainFields: (supportsEs2015 ? ['es2015'] : []).concat(['module', 'main'])
        },
        performance: {
            hints: false
        },
        plugins: [
            new ForkTsCheckerWebpackPlugin({
                tsconfig: options.tsConfig,
                workers: options.maxWorkers || ForkTsCheckerWebpackPlugin.TWO_CPUS_FREE
            })
        ],
        watch: options.watch,
        watchOptions: {
            poll: options.poll
        }
    };
    var extraPlugins = [];
    if (options.progress) {
        extraPlugins.push(new webpack_1.ProgressPlugin());
    }
    if (options.extractLicenses) {
        extraPlugins.push(new license_webpack_plugin_1.LicenseWebpackPlugin({
            pattern: /.*/,
            suppressErrors: true,
            perChunkOutput: false,
            outputFilename: "3rdpartylicenses.txt"
        }));
    }
    // process asset entries
    if (options.assets) {
        var copyWebpackPluginPatterns = options.assets.map(function (asset) {
            return {
                context: asset.input,
                // Now we remove starting slash to make Webpack place it from the output root.
                to: asset.output,
                ignore: asset.ignore,
                from: {
                    glob: asset.glob,
                    dot: true
                }
            };
        });
        var copyWebpackPluginOptions = {
            ignore: ['.gitkeep', '**/.DS_Store', '**/Thumbs.db']
        };
        var copyWebpackPluginInstance = new CopyWebpackPlugin(copyWebpackPluginPatterns, copyWebpackPluginOptions);
        extraPlugins.push(copyWebpackPluginInstance);
    }
    if (options.showCircularDependencies) {
        extraPlugins.push(new CircularDependencyPlugin({
            exclude: /[\\\/]node_modules[\\\/]/
        }));
    }
    webpackConfig.plugins = webpackConfig.plugins.concat(extraPlugins);
    return webpackConfig;
}
exports.getBaseWebpackPartial = getBaseWebpackPartial;
function getAliases(options, compilerOptions) {
    var replacements = options.fileReplacements.concat((compilerOptions.paths
        ? Object.entries(compilerOptions.paths).map(function (_a) {
            var importPath = _a[0], values = _a[1];
            return ({
                replace: importPath,
                with: path_1.resolve(options.root, values[0])
            });
        })
        : []));
    return replacements.reduce(function (aliases, replacement) {
        var _a;
        return (__assign({}, aliases, (_a = {}, _a[replacement.replace] = replacement.with, _a)));
    }, {});
}
